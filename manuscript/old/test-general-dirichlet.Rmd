---
title: "Untitled"
author: "Bret Larget"
date: "5/26/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Test Generalized Dirichlet Distribution

1. Generate random $\alpha$ and $\lambda$.
2. Generate gamma random variables and renormalize.
3. Calculate marginal means and variances.
4. Use formula to find estimated $\alpha$ and $\lambda$.
5. Compare to originals.

```{r test}
## x is an n by k matrix where row sums are one and elements are positive
estimate = function(x)
{
  m = apply(x,2,mean)
  v = apply(x,2,var)
  lambda = m*(1-m)/v
  alpha = m*lambda
  lambda = lambda/mean(lambda)
  return(data.frame(alpha,lambda))
}

parameters = function(k=4,mean.a=2000,shape=2)
{
  alpha = rgamma(k,shape,shape/mean.a)
  lambda = rgamma(k,shape,shape)
  lambda = lambda/mean(lambda)
  return(data.frame(alpha,lambda))
}

generate = function(p,n=1000)
{
  k = nrow(p)
  x = with(p, matrix(rgamma(n*k,rep(alpha,each=n),rep(lambda,each=n)),n,k) )
  s = apply(x,1,sum)
  for ( i in 1:n )
    x[i,] = x[i,] / s[i]
  return(x)
}
```

## Run the test

```{r run}
f = function(k,mean.a=2000,shape=2,n=1000)
{
  p = parameters(k,mean.a,shape)
  mu = p$alpha/p$lambda
  mu = mu/sum(mu)
  x = generate(p,n)
  p.hat = estimate(x)
  return(data.frame(alpha=p$alpha,
                    lambda=p$lambda,
                    alpha.hat=p.hat$alpha,
                    lambda.hat=p.hat$lambda,
                    mu=mu,
                    m=apply(x,2,mean),
                    v=apply(x,2,var)))
}

f(4)

```

```{r}
## Test Steve's ratio result
k = 10
n = 1000000
#### generate p
p = parameters(k=k,mean.a=1)
p1 = p
p1$alpha[1] = p$alpha[1] + 1
p2 = p
p2$alpha[2] = p$alpha[2] + 1
#### generate x
x = generate(p,n=n)
x1 = generate(p1,n=n)
x2 = generate(p2,n=n)
#### calculate means and variances
m = apply(x,2,mean)
m1 = apply(x1,2,mean)
m2 = apply(x2,2,mean)
v1 = apply(x1,2,var)
v2 = apply(x2,2,var)
#### compare ratios
r.emp = m2[1]/m1[2]
r.eq = (p$alpha[1]/p$lambda[1]) / (p$alpha[2]/p$lambda[2])
r.emp
r.eq
se.r.emp = sqrt( v2[1]/n/m1[2]^2 + m2[1]^2*v1[2]/n/m1[2]^4 )
se.r.emp
# CI
r.emp + c(-1,1)*1.96*se.r.emp
# z
z = (r.eq - r.emp) / se.r.emp
z
```

```{r}
# Explore k=2 for given alpha and lambda
k=2
n=10^6
lambda = c(0.5,1.5)
a1 = seq(1,10,1)
a2 = seq(1,10,1)
out = matrix(0,length(a1)*length(a2),5)
i=1
for ( a in a1 )
{
  for ( b in a2 )
  {
    print(i)
    p = data.frame(alpha=c(a,b),lambda=lambda)    
    p2 = p
    p2$alpha[2] = p$alpha[2] + 1
    x2 = generate(p2,n=n)
    m2 = apply(x2,2,mean)
    out[i,] = c(p$alpha,p$lambda,m2[2])
    i = i+1
  }
}

colnames(out) = c("alpha1","alpha2","lambda1","lambda2","m22")
out = data.frame(out)
out$m01 = with(out, (alpha1*lambda2 - (1-m22)*alpha2*(lambda1-lambda2)) / (lambda2*(alpha1+alpha2)) )
out$m02 =  with(out, (alpha2*lambda1 - m22*alpha2*(lambda1-lambda2)) / (lambda2*(alpha1+alpha2)) )
out$s = with(out, alpha1+alpha2)
out$p = with(out, alpha1/s)
out$r = with(out, lambda1/lambda2)
out1$s = with(out1, alpha1+alpha2)
out1$p = with(out1, alpha1/s)
out1$r = with(out1, lambda1/lambda2)
```

```{r}
# More exploration
k = 2
n = 10^6
pset = c(0.01,0.1,0.3,0.5,0.7,0.9,0.99)
sset = c(1,4,16,64,256)
rset = c(0.1,0.25,0.5,1,2,4,10)
i=1
total = length(pset) * length(sset) * length(rset)
out = matrix(0,total,13)
for ( p in pset )
{
  for ( s in sset )
  {
    for ( r in rset )
    {
      print(paste(i,"of",total))
      alpha = c(p*s,(1-p)*s)
      lambda = c(2*r/(1+r),2/(r+1))
      df = data.frame(alpha,lambda)
      df2 = df
      df2$alpha[2] = df$alpha[2] + 1
      x2 = generate(df2,n=n)
      m2 = apply(x2,2,mean)
      z = m2[2]
      m01 = p - (1-z)*(r-1)*(1-p)
      m02 = r*(1-p) - z*(r-1)*(1-p)
      m11 = 1 - (1-z)*r*(1-p)/p
      m12 = (1-z)*r*(1-p)/p
      m21 = 1-z
      out[i,] = c(alpha,lambda,r,p,s,m01,m02,m11,m12,m21,m22=z)
      i = i+1
    }
  }
}
colnames(out) = c("alpha1","alpha2","lambda1","lambda2","r","p","s","m01","m02","m11","m12","m21","m22")
out = data.frame(out)
```

```{r}
require(ggplot2)
ggplot(out, aes(x=log(p),y=log(m01))) + geom_line() + facet_grid(r ~ s)
ggplot(out, aes(x=s,y=m01)) + geom_line() + facet_grid(r ~ p)
ggplot(out, aes(x=log(r),y=m01)) + geom_line() + facet_grid(p ~ s)
ggplot(out, aes(x=s,y=log(m01)/log(p))) + geom_line() + facet_grid(. ~ r)
```
